import { AllState, ItemType, StepName } from "../types";
export declare function makeEffectsMaker<T_StoreName extends ItemType & string, T_StoreItemId extends keyof AllState[T_StoreName] & string, T_PropertyName extends keyof AllState[T_StoreName][T_StoreItemId] & string, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeName: T_StoreName, storeItemId: T_StoreItemId, storyProperty: T_PropertyName, stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callbacksMap: Partial<Record<any, (usefulStuff: T_UsefulParams) => void>>) => Record<"whenPropertyChanges", import("../types").Effect>;
export declare function makeLeaveEffectsMaker<T_StoreName extends ItemType & string, T_StoreItemId extends keyof AllState[T_StoreName] & string, T_PropertyName extends keyof AllState[T_StoreName][T_StoreItemId] & string, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeName: T_StoreName, storeItemId: T_StoreItemId, storyProperty: T_PropertyName, stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<any, (usefulStuff: T_UsefulParams) => void>>) => Record<"whenPropertyChanges", import("../types").Effect>;
/** Similar to makeEffectsMaker but accepts parameters for two store properties (can be from different stores) , and the callback fires when properties of both stores change */
export declare function makeNestedEffectsMaker<T_StoreName1 extends ItemType & string, T_StoreItemId1 extends keyof AllState[T_StoreName1] & string, T_PropName1 extends keyof AllState[T_StoreName1][T_StoreItemId1] & string, T_StoreName2 extends ItemType & string, T_StoreItemId2 extends keyof AllState[T_StoreName2] & string, T_PropName2 extends keyof AllState[T_StoreName2][T_StoreItemId2] & string, T_StepName extends StepName, T_UsefulParams extends Record<any, any>>(storeInfo1: [T_StoreName1, T_StoreItemId1, T_PropName1], storeInfo2: [T_StoreName2, T_StoreItemId2, T_PropName2], stepName?: T_StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<any, Partial<Record<any, (usefulStuff: ReturnType<NonNullable<typeof getUsefulParams>>) => void>>>>) => Record<"whenPropertyChanges", import("../types").Effect>;
/** The same as makeNestedRuleMaker , but the callback fires when the properties of both stores become NOT the specified values, but were previously */
export declare function makeNestedLeaveEffectsMaker<T_StoreName1 extends ItemType & string, T_StoreItemId1 extends keyof AllState[T_StoreName1] & string, T_PropertyName1 extends keyof AllState[T_StoreName1][T_StoreItemId1] & string, T_StoreName2 extends ItemType & string, T_StoreItemId2 extends keyof AllState[T_StoreName2] & string, T_PropertyName2 extends keyof AllState[T_StoreName2][T_StoreItemId2] & string, T_UsefulParams extends Record<any, any>>(storeInfo1: [T_StoreName1, T_StoreItemId1, T_PropertyName1], storeInfo2: [T_StoreName2, T_StoreItemId2, T_PropertyName2], stepName?: StepName, getUsefulParams?: () => T_UsefulParams): (callBacksObject: Partial<Record<any, Partial<Record<any, (usefulStuff: T_UsefulParams) => void>>>>) => Record<"whenPropertyChanges", import("../types").Effect>;
